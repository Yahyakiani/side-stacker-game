from sqlalchemy.orm import Session
from typing import Optional, Dict, Any, List
import uuid
from sqlalchemy.orm.attributes import flag_modified
from app.db.models import Game  # Your Game SQLAlchemy model
from app.schemas.game import (
    GameStateResponse,
)  # For type hinting return, though not strictly required here
from app.services.game_logic import (
    create_board as service_create_board,
)  # Renaming to avoid conflict

# For now, we'll focus on Create and Get. Update will be more complex with game logic.
# Delete might not be immediately necessary for active gameplay.


def get_game(db: Session, game_id: uuid.UUID) -> Optional[Game]:
    """
    Retrieves a game by its ID.
    """
    return db.query(Game).filter(Game.id == game_id).first()


def create_game_db(
    db: Session,
    player1_token: Optional[str] = None,
    player2_token: Optional[str] = None,
    game_mode: str = "PVP",
    initial_current_player_token: Optional[str] = None,
) -> Game:
    """
    Creates a new game in the database.
    The initial board state is set here.
    """
    # The default for board_state in the model handles empty board creation
    # But if you want to be explicit or pass a board generated by game_logic:
    initial_board_data = service_create_board()  # Uses our game_logic service

    db_game = Game(
        player1_token=player1_token,
        player2_token=player2_token,
        current_player_token=(
            initial_current_player_token
            if initial_current_player_token
            else player1_token
        ),
        board_state={"board": initial_board_data},  # Ensure it's a dict for JSONB
        status=(
            "waiting_for_player2"
            if game_mode == "PVP" and not player2_token
            else "active"
        ),
        game_mode=game_mode,
    )
    db.add(db_game)
    db.commit()
    db.refresh(db_game)  # Refresh to get DB-generated values like ID, created_at
    return db_game


def update_game_state(
    db: Session,
    game_id: uuid.UUID,
    board_state: Optional[
        Dict[str, Any]
    ] = None,  # e.g. {"board": List[List[str|None]]}
    current_player_token: Optional[str] = None,
    status: Optional[str] = None,
    winner_token: Optional[str] = None,  # Can be None or "draw" conceptually
) -> Optional[Game]:
    """
    Updates the state of an existing game.
    Only updates fields that are provided (not None).
    """
    db_game = get_game(db, game_id)
    if not db_game:
        return None

    update_data = {}
    if board_state is not None:
        update_data["board_state"] = board_state
    if (
        current_player_token is not None
        or current_player_token is None
        and "current_player_token" in locals()
    ):  # to allow setting to None
        update_data["current_player_token"] = current_player_token
    if status is not None:
        update_data["status"] = status
    if (
        winner_token is not None or winner_token is None and "winner_token" in locals()
    ):  # to allow setting to None
        update_data["winner_token"] = winner_token

    if not update_data:  # Nothing to update
        return db_game

    for key, value in update_data.items():
        setattr(db_game, key, value)
        if key == "board_state":  # If board_state was updated
            flag_modified(db_game, "board_state")

    print(
        f"DEBUG: Updating game {db_game.id} with board_state: {db_game.board_state}"
    )  # ADD THIS LINE
    print(
        f"DEBUG: Updating game {db_game.id} with current_player: {db_game.current_player_token}"
    )
    # db_game.updated_at will be updated by the DB due to onupdate=func.now()
    db.add(
        db_game
    )  # Not strictly necessary if only modifying existing fields of a tracked object
    db.commit()
    db.refresh(db_game)
    return db_game


# Placeholder for listing games if needed later
# def get_games(db: Session, skip: int = 0, limit: int = 100) -> List[Game]:
#     return db.query(Game).offset(skip).limit(limit).all()
