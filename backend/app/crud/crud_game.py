# File: crud_game.py
# backend/app/crud/crud_game.py

from sqlalchemy.orm import Session
from typing import Optional, Dict, Any, List
import uuid
from sqlalchemy.orm.attributes import flag_modified
from app.db.models import Game  # Game SQLAlchemy model
from app.services.game_logic import (
    create_board as service_create_board,
)  # Renaming to avoid conflict

from app.core.logging_config import setup_logger

logger = setup_logger(__name__)

def get_game(db: Session, game_id: uuid.UUID) -> Optional[Game]:
    """
    Retrieves a game by its ID.
    """
    game = db.get(Game, game_id)  # .get() is efficient for PK lookups
    if game:
        # Expire the instance. The next access to its attributes
        # will trigger a reload from the database, reflecting changes
        # committed by other sessions.
        logger.debug(
            f"DEBUG crud get_game: Found game {game_id} in session {id(db)}. Expiring it."
        )
        db.expire(game)
        # No need to explicitly refresh here; access in calling code will do it.
        # For example, when game.status is checked in game_ws.py, it will reload.
    else:
        logger.debug(
            f"DEBUG crud get_game: Game {game_id} not found by db.get() in session {id(db)}. Will try query."
        )
        # If db.get() didn't find it (e.g., not in identity map yet), a query will fetch it.
        # This path is less likely if the object was previously handled by this session.
        # This is more of a fallback if db.get() returns None but the object might exist.
        # game = db.query(Game).filter(Game.id == game_id).first() # Alternative fetch
        # if game:
        #     print(f"DEBUG crud get_game: Fetched game {game_id} via query, status: {game.status}")

    # Returning 'game' (which might be None if not found at all, or the expired instance)
    # Accessing attributes of an expired instance in the caller will trigger a SELECT.
    return game


def create_game_db(
    db: Session,
    player1_token: Optional[str] = None,
    player2_token: Optional[str] = None,
    game_mode: str = "PVP",
    initial_current_player_token: Optional[str] = None,
) -> Game:
    """
    Creates a new game in the database.
    The initial board state is set here.
    """
    # The default for board_state in the model handles empty board creation
    # But if you want to be explicit or pass a board generated by game_logic:
    initial_board_data = service_create_board()  # Uses our game_logic service

    db_game = Game(
        player1_token=player1_token,
        player2_token=player2_token,
        current_player_token=(
            initial_current_player_token
            if initial_current_player_token
            else player1_token
        ),
        board_state={"board": initial_board_data},  # Ensure it's a dict for JSONB
        status=(
            "waiting_for_player2"
            if game_mode == "PVP" and not player2_token
            else "active"
        ),
        game_mode=game_mode,
    )
    db.add(db_game)
    db.commit()
    db.refresh(db_game)  # Refresh to get DB-generated values like ID, created_at
    return db_game


def update_game_state(
    db: Session,
    game_id: uuid.UUID,
    board_state: Optional[Dict[str, Any]] = None,
    current_player_token: Optional[str] = "SENTINEL_DEFAULT",  # Use a sentinel
    status: Optional[str] = None,
    winner_token: Optional[str] = "SENTINEL_DEFAULT",  # Use a sentinel
    player1_token: Optional[str] = "SENTINEL_DEFAULT",  # Use a sentinel
    player2_token: Optional[str] = "SENTINEL_DEFAULT",  # Use a sentinel
) -> Optional[Game]:
    db_game = get_game(db, game_id)
    if not db_game:
        return None

    updated_fields_count = 0

    if (
        board_state is not None
    ):  # board_state is not optional in the same way as others for this func
        db_game.board_state = board_state
        flag_modified(db_game, "board_state")
        updated_fields_count += 1

    if status is not None:  # status also typically provided if changing
        db_game.status = status
        updated_fields_count += 1

    # For fields that can be explicitly set to None if a value (even None) is passed,
    # or remain unchanged if the sentinel default is kept by the caller.
    if current_player_token != "SENTINEL_DEFAULT":
        db_game.current_player_token = current_player_token
        updated_fields_count += 1

    if winner_token != "SENTINEL_DEFAULT":
        db_game.winner_token = winner_token
        updated_fields_count += 1

    if player1_token != "SENTINEL_DEFAULT":  # Only update if not sentinel
        db_game.player1_token = player1_token
        updated_fields_count += 1

    if player2_token != "SENTINEL_DEFAULT":  # Only update if not sentinel
        db_game.player2_token = player2_token
        updated_fields_count += 1

    if updated_fields_count == 0:
        # No actual updates were requested for the fields this function handles
        # based on the parameters passed (excluding game_id which is for lookup)
        return db_game  # Return the fetched game without commit/refresh

    # print(f"DEBUG crud: About to commit updates for game {db_game.id} - P1: {db_game.player1_token}, P2: {db_game.player2_token}, Status: {db_game.status}, CurrentP: {db_game.current_player_token}")

    db.commit()
    db.refresh(db_game)
    # print(f"DEBUG crud: After commit for game {db_game.id} - P1: {db_game.player1_token}, P2: {db_game.player2_token}, Status: {db_game.status}, CurrentP: {db_game.current_player_token}")
    return db_game


# Placeholder for listing games if needed later
# def get_games(db: Session, skip: int = 0, limit: int = 100) -> List[Game]:
#     return db.query(Game).offset(skip).limit(limit).all()
